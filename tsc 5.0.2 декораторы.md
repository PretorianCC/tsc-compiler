## Декораторы

## Введение

С введением классов в TypeScript и ES6 теперь существуют определенные сценарии, которые требуют дополнительных функций для поддержки аннотирования или изменения классов и членов классов. Декораторы обеспечивают способ добавления как аннотаций, так и синтаксиса метапрограммирования для объявлений классов и членов. Декораторы являются предложением этапа 2 для JavaScript и доступны в качестве экспериментальной функции TypeScript.

> ЗАМЕТКА: Декораторы - экспериментальная функция, которая может измениться в будущих выпусках.

Чтобы включить экспериментальную поддержку декораторов, вы должны использовать `experimentalDecorators` в командной строке или в вашем tsconfig.json:

**Command Line**:

```sh
tsc --target ES5 --experimentalDecorators
```

**tsconfig.json**:

``` json
{
	"compilerOptions":
	{
		"target": "ES5",
		"experimentalDecorators": true
    }
}
```

## Декораторы

Декоратор - это специальный вид объявления, которое может быть присоединено к объявлению класса, методу, средству доступа, свойству или параметру. Декораторы используют выражение @выражение, где выражение должно вычисляться до функции, которая будет вызвана во время выполнения с информацией о декорированном объявлении.

Например, учитывая декоратор @sealed , мы можем записать изолированную функцию следующим образом:

```ts
function sealed(target) {
	// сделать что-то с 'target' ...
}
```

## Фабрики декораторов

Если мы хотим настроить способ применения декоратора к объявлению, мы можем написать фабрику декоратора. Фабрика декоратора - это просто функция, которая возвращает выражение, которое будет вызвано декоратором во время выполнения.

Мы можем написать фабрику декоратора следующим образом:

```ts
function color(value: string) {
	// это фабрика декораторов, она настраивает
	// в возвращяемой функции декоратора
	return function (target) {
		// это декоратор
		// сделать что-то с 'target' и 'value'...
	};
}
```

## Композиция декоратора

К объявлению можно применить несколько декораторов, например, в одной строке:

```ts
@f @g x
```

На нескольких строках:

```ts
@f
@g
x
```

Когда несколько декораторов применяются к одному объявлению, они похожи на композицию функции в математике. В этой модели при составлении функций `f` и `g` результирующий композит `(f ∘ g) (x)` эквивалентен `f (g (x))`.

При использовании нескольких декораторов в одном объявлении в TypeScript выполняются следующие шаги:

1. Выражения для каждого декоратора вычисляются сверху вниз.
2. Результаты затем вызываются как функции снизу вверх.

Если бы мы использовали фабрику декоратора, мы могли бы наблюдать этот порядок использования на следующем примере:

```ts
function first() {
	console.log("first(): factory evaluated");
	return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
		console.log("first(): called");
	};
}

function second() {
	console.log("second(): factory evaluated");
	return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
		console.log("second(): called");
	};
}

class ExampleClass {
	@first()
	@second()
	method() {}
}
```

Который печатает эти данные на консоли:

```sh
first(): factory evaluated
second(): factory evaluated
second(): called  first(): called
```

## Применение декоратора

Существует четко определенный порядок применения декораторов к различным объявлениям внутри класса:

1. Для каждого элемента экземпляра применяются декораторы параметров, за которыми следуют декораторы методов, модификаторы доступа или свойства.
2. Для каждого статического элемента применяются декораторы параметров, за которыми следуют декораторы методов, модификаторы доступа или свойства.
3. Для конструктора применяются декораторы параметров.
4. Для класса применяются декораторы класса.

## Декораторы класса

Декоратор класса объявляется непосредственно перед объявлением класса. Декоратор класса применяется к конструктору класса и может использоваться для наблюдения, изменения или замены определения класса. Декоратор класса не может использоваться в файле объявления или в любом другом окружающем контексте (например, в объявлении класса).

Выражение для декоратора класса будет вызываться как функция во время выполнения, с конструктором декорированного класса в качестве единственного аргумента.

Если декоратор класса возвращает значение, оно заменяет объявление класса на предоставленную функцию конструктора.

> ПРИМЕЧАНИЕ: В случае возврата новой функции конструктора необходимо позаботиться о сохранении исходного прототипа. Логика, применяющая декораторы во время выполнения, не сделает этого за вас.

Ниже приведен пример декоратора класса (`@sealed`), примененного к классу `BugReport`:

```ts
@sealed
class BugReport {
	type = "report";
	title: string;
	constructor(t: string) {
		this.title = t;
	}
}
```

Мы можем определить @sealed декоратор, используя следующее объявление функции:

```ts
function sealed(constructor: Function) {
	Object.seal(constructor);
	Object.seal(constructor.prototype);
}
```

Когда `@sealed` выполняется, он ведет себя как конструктор, так же и его прототип, следовательно, предотвращает добавление или удаление каких-либо дополнительных функций из этого класса во время выполнения, обращаясь к `BugReport.prototype` или определяя свойства в самом `BugReport` (обратите внимание, что классы ES2015 действительно являются просто синтаксическим сахаром для функций конструктора на основе прототипа). Этот декоратор не запрещает классам наследовать `BugReport`.

Далее приведен пример переопределения конструктора для установки новых значений по умолчанию.

```ts
function reportableClassDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {
	return class extends constructor {
		reportingURL = "http://www...";
	};
}

@reportableClassDecoratorclass
BugReport {
	type = "report";
	title: string;
	
	constructor(t: string) {
		this.title = t;
	}
}

const bug = new BugReport("Needs dark mode");
console.log(bug.title); // Вывести "Needs dark mode"
console.log(bug.type); // Вывести "report"

// Обратите внимание, что decorator не изменяет тип TypeScript
// и поэтому новое свойство 'reportURL' неизвестно
// в системе типов:
bug.reportingURL; // Свойство 'reportingURL' не существует в типе 'BugReport'.
```

## Декораторы методов

Декоратор метода объявляется непосредственно перед объявлением метода. Декоратор применяется к дескриптору свойства для метода и может использоваться для наблюдения, изменения или замены определения метода. Декоратор метода не может использоваться в файле объявления, при перегрузке или в любом другом окружающем контексте (например, в классе объявления).

Выражение для декоратора метода будет вызываться как функция во время выполнения со следующими тремя аргументами:

1. Либо функция конструктора класса для статического члена, либо прототип класса для члена экземпляра.
2. Имя элемента.
3. Дескриптор свойства для элемента.

> ПРИМЕЧАНИЕ: Дескриптор свойства не будет определен, если конечный код программы меньше ES5.

Если декоратор метода возвращает значение, оно будет использоваться в качестве дескриптора свойства для метода.

> ПРИМЕЧАНИЕ: Возвращаемое значение игнорируется, если код программы меньше ES5.

Ниже приведен пример декоратора метода (`@enumerable`), примененного к методу класса `Greeter`:

```ts
class Greeter {
	greeting: string;
	
	constructor(message: string) {
		this.greeting = message;
	}

	@enumerable(false)
	greet() {
		return "Hello, " + this.greeting;
	}
}
```

Можно определить @enumerable декоратор, используя следующее объявление функции:

```ts
function enumerable(value: boolean) {
	return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
		descriptor.enumerable = value;
	};
}
```

Декоратор `@enumerable(false)` является фабрикой декораторов. При вызове `@enumerable(false)` декоратор изменяет `enumerable` свойство, дескриптора свойства.

## Декораторы доступа

Декоратор доступа объявляется непосредственно перед объявлением модификатора доступа. Декоратор модификатора доступа применяется к дескриптору свойства для модификатора доступа и может использоваться для наблюдения, изменения или замены определений средств доступа. Декоратор метода доступа не может использоваться в файле объявления или в любом другом окружающем контексте (например, в классе объявления).

> ПРИМЕЧАНИЕ: TypeScript запрещает декорирование метода доступа get и set для одного члена. Вместо этого все декораторы для элемента должны быть применены к первому модификатору доступа, указанному в порядке документа. Это происходит потому, что декораторы применяются к дескриптору свойства, который объединяет метод доступа get и set, а не каждое объявление отдельно.

Выражение для декоратора метода доступа будет вызываться как функция во время выполнения со следующими тремя аргументами:

1. Либо функция конструктора класса для статического члена, либо прототип класса для члена экземпляра.
2. Имя элемента.
3. Дескриптор свойства для элемента.

> ПРИМЕЧАНИЕ: Дескриптор свойства не будет определен, если конечный код программы меньше ES5.

Если декоратор доступа возвращает значение, оно будет использоваться в качестве дескриптора свойства для элемента.

> ПРИМЕЧАНИЕ: Возвращаемое значение игнорируется, если код сценария меньше ES5.

Ниже приведен пример декоратора метода доступа (`@configuration`), примененного к члену класса `Point`:

```ts
class Point {
	private _x: number;
	private _y: number;
	
	constructor(x: number, y: number) {
		this._x = x;
		this._y = y;
	}
	
	@configurable(false)
	get x() {
		return this._x;
	}
	
	@configurable(false)
	get y() {
		return this._y;
	}
}
```

Можно определить @configurable декоратор, используя следующее объявление функции:

```ts
function configurable(value: boolean) {
	return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
		descriptor.configurable = value;
	};
}
```

## Декораторы свойств

Декоратор свойств объявляется непосредственно перед объявлением свойств. Декоратор свойств не может использоваться в файле объявления или в любом другом окружающем контексте (например, в объявлении класса).

Выражение для декоратора свойств будет вызываться как функция во время выполнения со следующими двумя аргументами:

1. Либо функция конструктора класса для статического члена, либо прототип класса для члена экземпляра.
2. Имя элемента.

> ПРИМЕЧАНИЕ: Дескриптор свойства не предоставляется в качестве аргумента для декоратора свойства из-за того, что декораторы свойств инициализируются в TypeScript. Это связано с тем, что в настоящее время отсутствует механизм описания свойства экземпляра при определении элементов прототипа, а также нет возможности наблюдать или изменять инициализатор свойства. Возвращаемое значение также игнорируется. По существу, декоратор свойств может использоваться только для наблюдения за тем, что свойство определенного имени было объявлено для класса.

Эту информацию можно использовать для записи метаданных о свойстве, как в следующем примере:

```ts
class Greeter {
	@format("Hello, %s")
	greeting: string;
	
	constructor(message: string) {
		this.greeting = message;
	}
	
	greet() {
		let formatString = getFormat(this, "greeting");
		return formatString.replace("%s", this.greeting);
	}
}
```

Затем можно определить функцию декоратор `@format` и `getFormat`, используя следующие объявления функций:

```ts
import "reflect-metadata";

const formatMetadataKey = Symbol("format");

function format(formatString: string) {
	return Reflect.metadata(formatMetadataKey, formatString);
}

function getFormat(target: any, propertyKey: string) {
	return Reflect.getMetadata(formatMetadataKey, target, propertyKey);
}
```

Декоратор `@format("Hello, %s")` является фабрикой декораторов. При вызове `@format ("Hello, %s")` добавляется запись метаданных для свойства с помощью функции `Reflect.metadata` из библиотеки reflect-metadata. При вызове метода `getFormat` считывается значение метаданных для формата.

> ПРИМЕЧАНИЕ: В этом примере требуется библиотека reflect-metadata. Дополнительные сведения о библиотеке reflect-metadata см. в разделе Метаданные.

## Декораторы параметров

Декоратор параметров объявляется непосредственно перед объявлением параметров. Декоратор параметров применяется к функции, для конструктора класса или объявления метода. Декоратор параметров не может использоваться в файле объявления, перегрузке или в любом другом окружающем контексте (например, в классе объявления).

Выражение для декоратора параметров будет вызываться как функция во время выполнения со следующими тремя аргументами:

1. Либо функция конструктора класса для статического члена, либо прототип класса для члена экземпляра.
2. Имя элемента.
3. Порядковый индекс параметра в списке параметров функции.

> ПРИМЕЧАНИЕ: Декоратор параметров может использоваться только для наблюдения за тем, что параметр был объявлен в методе.

Возвращаемое значение декоратора параметров игнорируется.

Ниже приведен пример декоратора параметров (`@required`), примененного к параметру члена класса `BugReport`:

```ts

class BugReport {
	type = "report";
	title: string;
	
	constructor(t: string) {
		this.title = t;
	}
	
	@validate
	print(@required verbose: boolean) {
		if (verbose) {
			return `type: ${this.type}\ntitle: ${this.title}`;
		} else {
			return this.title;
		}
	}
}
```

Затем можно определить `@required` и `@validate` декораторы, используя следующие объявления функций:

```ts

import "reflect-metadata";

const requiredMetadataKey = Symbol("required");

function required(target: Object, propertyKey: string | symbol, parameterIndex: number) {
	let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || []; 
	existingRequiredParameters.push(parameterIndex);
	Reflect.defineMetadata( requiredMetadataKey, existingRequiredParameters, target, propertyKey);
}

function validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {
	let method = descriptor.value!;
	descriptor.value = function () {
		let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);
		if (requiredParameters) {
			for (let parameterIndex of requiredParameters) {
				if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {
					throw new Error("Missing required argument.");
				}
			}
		}
		return method.apply(this, arguments);
	};
}
```

`@required` декоратор добавляет элемент метаданных, который помечается как необходимый параметр. Затем `@validate` декоратор переносит существующий метод приветствия в функцию, которая проверяет аргументы перед вызовом исходного метода.

> ПРИМЕЧАНИЕ: В этом примере требуется библиотека `reflect-metadata`. Дополнительные сведения о библиотеке `reflect-metadata` см. в разделе Метаданные.

## Метаданные

В некоторых примерах используется библиотека `reflect-metadata`, которая добавляет полифил для экспериментального API метаданных. Эта библиотека еще не является частью стандарта ECMAScript (JavaScript). Однако после официального принятия декораторов в рамках стандарта ECMAScript эти расширения будут предложены для их принятия.

Эту библиотеку можно установить с помощью npm:

```sh
npm i reflect-metadata --save
```

TypeScript включает экспериментальную поддержку передачи определенных типов метаданных для объявлений, имеющих декораторы. Чтобы включить эту экспериментальную поддержку, необходимо установить параметр компилятора `emitDecorateMetadata` в командной строке или в файле tsconfig.json:

**Командная строка:**

```sh
tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata
```

**tsconfig.json**:

```json
{
	"compilerOptions": {
		"target": "ES5",
		"experimentalDecorators": true,
		"emitDecoratorMetadata": true
	}
}
```

Если этот параметр включен, при импорте библиотеки `reflect-metadata` во время выполнения будут отображаться дополнительные сведения о типе во время.

Мы можем увидеть это в действии в следующем примере:

```ts
import "reflect-metadata";

class Point {
	constructor(public x: number, public y: number) {}
}

class Line {
	private _start: Point;
	private _end: Point;
	
	@validate
	set start(value: Point) {
		this._start = value;
	}
	
	get start() {
		return this._start;
	}
	
	@validate
	set end(value: Point) {
		this._end = value;
	}
	
	get end() {
		return this._end;
	}
}

function validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) {
	let set = descriptor.set!;
	descriptor.set = function (value: T) {
		let type = Reflect.getMetadata("design:type", target, propertyKey);
		if (!(value instanceof type)) {
			throw new TypeError(`Invalid type, got ${typeof value} not ${type.name}.`);
		}
		set.call(this, value);
	};
}

const line = new Line()
line.start = new Point(0, 0)

// @ts-ignore
// line.end = {}

// Сбой во время выполнения с ошибкой:
// > Invalid type, got object not Point
```

Компилятор TypeScript будет добавлять сведения о типе времени разработки с помощью декоратора @Reflect.metadata. Его можно считать эквивалентом следующего в TypeScript:

```ts
class Line {
	private _start: Point;
	private _end: Point;
	
	@validate
	@Reflect.metadata("design:type", Point)
	set start(value: Point) {
		this._start = value;
	}
	
	get start() {
		return this._start;
	}
	
	@validate
	@Reflect.metadata("design:type", Point)
	set end(value: Point) {
		this._end = value;
	}
	
	get end() {
		return this._end;
	}
}
```

ПРИМЕЧАНИЕ: Метаданные декоратора представляют собой экспериментальную функцию и могут быть изменены в будущих версиях.