## Перечисления

Перечисления являются одной из немногих функций TypeScript, которая не является расширением JavaScript на уровне типов.

Перечисления позволяют разработчику определить набор именованных констант. Использование перечислений может упростить документирование намерений или создание набора отдельных вариантов. TypeScript предоставляет числовые и строковые перечисления.

### Числовые перечисления

Сначала начнем с числовых перечислений, которые, вероятно, более привычны, если вы родом из других языков. Перечисление можно определить с помощью ключевого слова `enum`.

```ts
enum Direction {
    Up = 1,
    Down,
    Left,
    Right,
}
```

Выше мы имеем числовое перечисление, где `Up` инициализируется с 1. Все следующие элементы автоматически увеличиваются с этой точки. Другими словами, `Direction.Up` имеет значение 1, `Down` - 2, `Left` - 3, `Right` - 4.

Если бы мы хотели, мы могли бы полностью убрать инициализатор:

```ts
enum Direction {
    Up,
    Down,
    Left,
    Right,
}
```

Здесь `Up` будет иметь значение 0, `Down` будет иметь 1 и т.д. Это поведение автоматического приращения полезно для случаев, когда мы можем не беспокоиться о самих значениях элемента, но должны быть уверены, что каждое значение отличается от других значений в том же перечислении.

Использовать перечисление просто: получите доступ к любому члену в качестве свойства вне самого перечисления и объявите типы, используя имя перечисления:

```ts
enum UserResponse {
    No = 0,
    Yes = 1,
}

function respond(recipient: string, message: UserResponse): void {
    // ...
}

respond("Princess Caroline", UserResponse.Yes);
```

Числовые перечисления могут смешиваться в вычисляемых и постоянных элементах (см. ниже). Дело заключается в том, что перечисления без инициализаторов либо должны быть раньше, либо должны быть после числовых перечислений, инициализированных числовыми константами или другими постоянными элементами перечисления. Другими словами, не допускается следующее:

```ts
enum E {
    A = getSomeValue(),
    B, // Член перечисления должен иметь инициализатор.
}
```

### Строковые перечисления

Строковые перечисления имеют сходное понятие, но имеют некоторые тонкие различия во время выполнения, как описано ниже. В строковом перечислении каждый элемент должен быть постоянно инициализирован строковым литералом или другим строковым элементом перечисления.

```ts
enum Direction {
	Up = "UP",\
	Down = "DOWN",
	Left = "LEFT",
	Right = "RIGHT",
}
```

Хотя строковые перечисления не имеют автоматического приращения, они хорошо «сериализируются». Другими словами, если вы отлаживаете и должны прочитать значение во время отладки и это числовое перечисление, это значение часто непонятно - оно не передает никакой сути значения само по себе (хотя обратное отображение часто может помочь). Строковые перечисления позволяют давать значимое и читаемое значение при запуске кода независимо от имени самого элемента перечисления.

### Гетерогенные перечисления

Технически перечисления могут быть смешанными, со строковыми и числовыми членами, но непонятно почему, вы бы захотели это использовать когда-либо:

```ts
enum BooleanLikeHeterogeneousEnum {
    No = 0,
    Yes = "YES",
}
```

Если вы действительно пытаетесь использовать преимущества среды выполнения JavaScript по уму, рекомендуется не делать этого.

### Вычисляемые и постоянные элементы

Каждый элемент перечисления имеет связанное с ним значение, которое может быть константой или вычисляемым. Элемент перечисления считается константой, если:

-   Он является первым членом перечисления и не имеет инициализатора, в этом случае ему присваивается значение 0:

```ts
// E.X является константой:
enum E {
    X,
}
```

-   Он не имеет инициализатора, и предшествующий элемент перечисления был числовой константой. В этом случае значение текущего элемента перечисления будет значением предыдущего элемента перечисления плюс один.

```ts
// Все члены перечисления в «E1» и «E2» являются константами.

enum E1 {
    X,
    Y,
    Z,
}

enum E2 {
    A = 1,
    B,
    C,
}
```

Элемент перечисления инициализируется константным выражением перечисления. Константное выражение перечисления - это подмножество выражений TypeScript, которые можно полностью вычислить во время компиляции. Выражение является константным выражением перечисления, если оно является:

1. выражение перечисления литерала (в основном строковый литерал или числовой литерал)
2. ссылка на ранее определенный элемент перечисления константы (который может исходить из другого перечисления)
3. выражение перечисления констант в скобках
4. один из унарных операторов `+`, `-`, `~`, применяемых к выражению константного перечисления
5. `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`, `&`, `|`, `^` двоичные операторы с константными перечислениями в качестве операндов

Будет ошибка во времени компиляции для выражений константного перечисления, которые должны вычисляться для `NaN` или `Infinity`.

Во всех остальных случаях элемент перечисления считается вычисленным.

### Объединяемые перечисления и типы элементов перечисления

Существует специальное подмножество константных членов перечисления, которые не вычисляются: литеральные члены перечисления. Литеральный элемент перечисления является константным элементом перечисления без инициализированного значения или со значениями, инициализированными для:

-   любой строковый литерал (например, «foo», «bar», «baz»)
-   любой числовой литерал (например, 1, 100)
-   унарный минус, применяемый к любому числовому литералу (например, -1, -100)

Когда все члены в перечислении имеют литеральные значения перечисления, в действие вступает некоторая особая семантика.

Первое заключается в том, что члены перечисления также становятся типами! Например, можно сказать, что некоторые члены могут иметь только значение элемента перечисления:

```ts
enum ShapeKind {
    Circle,
    Square,
}

interface Circle {
    kind: ShapeKind.Circle;
    radius: number;
}

interface Square {
    kind: ShapeKind.Square;
    sideLength: number;
}

let c: Circle = {
    kind: ShapeKind.Square, // Тип «ShapeKind.Square» нельзя назначить типу «ShapeKind.Circle».
    radius: 100,
};
```

Другое изменение состоит в том, что сами типы перечисления фактически становятся объединением каждого члена перечисления. С помощью перечислений соединений система типов может использовать тот факт, что она знает точный набор значений, существующих в самом перечислении. Из-за этого TypeScript может обнаруживать ошибки, в которых возможно неправильное сравнение значений. Например:

```ts
enum E {
    Foo,
    Bar,
}

function f(x: E) {
    if (x !== E.Foo || x !== E.Bar) {
        // Это сравнение представляется непреднамеренным, поскольку типы «E.Foo» и «E.Bar» не имеют совпадений.
        //
    }
}
```

В этом примере мы сначала проверили, не является ли `x` `E.Foo`. Если это сравнение будет успешным, то наша `||` будет истиной, и тело «if» будет работать. Однако если проверка не удалась, то `x` может быть `E.Bar`, но в данном случае нет смысла проверять равен ли он `E.Bar`, если первая проверка истина.

### Перечисления во время выполнения

Перечисления - это реальные объекты, существующие во время выполнения. Например, следующее перечисление

```ts
enum E {
    X,
    Y,
    Z,
}
```

фактически может передаваться в функции

```ts
enum E {
    X,
    Y,
    Z,
}

function f(obj: { X: number }) {
    return obj.X;
}

// Работает, так как 'E' имеет свойство с именем 'X', которое является числом.
f(E);
```

### Перечисления во время компиляции

Несмотря на то, что перечисления являются реальными объектами, существующими во время выполнения, ключевое слово `keyof` работает иначе, чем можно ожидать для типичных объектов. Вместо этого используйте `keyof typeof`, чтобы получить тип, который представляет все ключи перечисления в виде строк.

```ts
enum LogLevel {
    ERROR,
    WARN,
    INFO,
    DEBUG,
}

/**
 * Это эквивалентно:
 * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';
 */
type LogLevelStrings = keyof typeof LogLevel;

function printImportant(key: LogLevelStrings, message: string) {
    const num = LogLevel[key];
    if (num <= LogLevel.WARN) {
        console.log("Лог уровня ключа:", key);
        console.log("Лог уровня значения:", num);
        console.log("Лог уровня сообщения:", message);
    }
}

printImportant("ERROR", "Это сообщение");
```

#### Обратные сопоставления

Помимо создания объекта с именами свойств для членов, члены числовых перечислений также получают обратное сопоставление от значений перечисления к именам перечисления. Например, в этом примере:

```ts
enum Enum {
    A,
}

let a = Enum.A;
let nameOfA = Enum[a]; // "A"
```

TypeScript компилирует его в соответствии с JavaScript:

```ts
"use strict";
var Enum;
(function (Enum) {
    Enum[(Enum["A"] = 0)] = "A";
})(Enum || (Enum = {}));
let a = Enum.A;
let nameOfA = Enum[a]; // "A"
```

В этом сгенерированном коде перечисление компилируется в объект, в котором хранятся как прямые (имя - > значение), так и обратные (значение - > имя) сопоставления. Ссылки на другие элементы перечисления всегда даются как доступ к свойствам и никогда не встраиваются.

Помните, что элементы перечисления строк вообще не получают обратного сопоставления.

#### Константа перечисления

В большинстве случаев перечисления являются вполне хорошим решением. Однако иногда требования бывают более жесткие. Чтобы избежать стоимости дополнительного сгенерированного кода и дополнительной косвенности при доступе к значениям перечисления, можно использовать `const` перечисления. Константные перечисления определяются с использованием модификатора `const` в наших перечислениях:

```ts
const enum Enum {
    A = 1,
    B = A * 2,
}
```

В константных перечислениях могут использовать только постоянные выражения перечисления и в отличие от регулярных перечислений они полностью удаляются во время компиляции. Члены `const enum` встроены в места использования. Это возможно, так как константные перечисления не могут иметь вычисляемых членов.

```ts
const enum Direction {
    Up,
    Down,
    Left,
    Right,
}

let directions = [
    Direction.Up,
    Direction.Down,
    Direction.Left,
    Direction.Right,
];
```

в сгенерированном коде станет:

```ts
"use strict";
let directions = [
    0 /* Direction.Up */, 1 /* Direction.Down */, 2 /* Direction.Left */,
    3 /* Direction.Right */,
];
```

#### Подводные камни `const enum`

Вложение значений перечислений вроде просты, но имеет одну тонкость. Эти подводные камни относятся только к окружению `const enum` (в основном `const enum` в файлах `.d.ts`) и делятся этим между проектами, но если вы публикуете или используете файлы `.d.ts`, то вероятно, это применимо и к вам, потому что `tsc --declaration` преобразует файлы `.ts` в файлы `.d.ts`.

1. По причинам, изложенным в документации по `isolatedModules`, этот режим принципиально несовместим с окружающими перечислениями `const`. Это означает, что при публикации внешних перечислений `const`, последующие потребители не смогут одновременно использовать `isolatedModules` и эти значения перечисления.
2. Можно легко встроить значения из версии `A` зависимости во время компиляции и импортировать версию `B` во время выполнения. Перечисления версий `A` и `B` могут иметь разные значения, если вы не очень внимательны, что приводит к неожиданным ошибкам, например, принятию неправильных ветвей операторов `if`. Эти ошибки особенно опасны, потому что обычно автоматические тесты запускаются примерно одновременно с построением проектов с теми же версиями зависимостей, которые полностью пропускают эти ошибки.
3. `importsNotUsedAsValues`: сохраняет и не будет игнорировать импорт для константы перечисления используемых в качестве значений, но константа перечисления не гарантирует, что во время выполнения `.js` файлы существуют. Неразрешимый импорт приводит к ошибкам во время выполнения. Обычный способ однозначного исключения импорта, только импорт типа, в настоящее время не допускается значение `const enum`.

Вот два подхода, чтобы избежать этих подводных камней:

Вообще не используйте константы перечисления. Можно легко запретить константы перечисления с помощью линтера. Очевидно, что это позволит избежать проблем с константами перечислениями, но не позволит вашему проекту встроить собственные перечисления. В отличие от встроенных перечислений других проектов, вложение собственных перечислений проекта не является проблематичным и имеет последствия для производительности. Не публикуйте окружающие константные перечисления, их с помощью `PreserureConstEnums`. Этот подход используется внутри проекта TypeScript. `preserityConstEnums` выдает тот же JavaScript для константных перечислений, что и простые перечисления. Затем можно безопасно удалить модификатор `const` из файлов `.d.ts` на этапе компиляции.

Таким образом, нижестоящие потребители не будут вставлять перечисления из вашего проекта, избегая вышеописанных проблем, но проект по-прежнему сможет встраивать свои собственные перечисления, в отличие от полного запрета перечислений `const`.

### Перечисления окружающей среды

Перечисления окружающей среды используются для описания формы уже существующих типов перечислений.

```ts
declare enum Enum {
    A = 1,
    B,
    C = 2,
}
```

Одно из важных различий между перечислениями окружающей и неокружительной среды состоит в том, что в обычных перечислениях члены, не имеющие инициализатора, будут считаться постоянными, если их предшествующий элемент перечисления будет считаться постоянным. Напротив, элемент константы который не имеет инициализатора, всегда считается вычисленным.

### Объекты против перечислений

В современном TypeScript перечисление может не понадобиться, если объекта с параметром `as const` может быть достаточно:

```ts
const enum EDirection {
    Up,
    Down,
    Left,
    Right,
}

const ODirection = {
    Up: 0,
    Down: 1,
    Left: 2,
    Right: 3,
} as const;

EDirection.Up; // (член перечисления) EDirection.Up = 0

ODirection.Up; // (свойство) Up: 0

// Использование перечисления в качестве параметра
function walk(dir: EDirection) {}

// Для извлечения значений требуется дополнительная строка
type Direction = (typeof ODirection)[keyof typeof ODirection];
function run(dir: Direction) {}

walk(EDirection.Left);
run(ODirection.Right);
```

Самый большой аргумент в пользу этого формата по сравнению с перечислением TypeScript заключается в том, что база кода поддерживается в соответствии с состоянием JavaScript, и когда/если перечисления добавляются в JavaScript, можно перейти к дополнительному синтаксису.
