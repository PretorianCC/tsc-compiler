## Дженерики

Основная часть разработки программного обеспечения - создание компонентов, которые не только имеют четко определенные и согласованные API, но и могут быть повторно использованы. Компоненты, которые способны работать как с данными сегодняшнего дня, так и с данными завтрашнего дня, дадут вам самые гибкие возможности для построения крупных программных систем.

В таких языках, как C# и Java, одним из основных инструментов на панели инструментов для создания многократно используемых компонентов являются дженерики, т.е. возможность создания компонента, который может работать с различными типами, а не с одним. Это позволяет пользователям использовать эти компоненты и их собственные типы.

### Здравствуй, мир дженериков

Для начала давайте сделаем «hello world» для дженериков: функцию идентичности. Функция идентичности- это функция, которая возвращает назад все передаваемое. Это работает аналогично команде `echo`.

```ts
function identity(arg: number): number {
    return arg;
}
```

Или мы могли бы описать функцию идентичности, используя любой тип:

```ts
function identity(arg: any): any {
    return arg;
}
```

Суть использования любого дженерика будет в том, что он будет заставлять функцию принимать any и все типы для arg, мы на самом деле теряем информацию о том, что за тип был, когда функция возвращается. Если мы передали бы number, единственная информация у нас будет что возвращаемый тип any.

Вместо этого нам нужен способ получения типа аргумента таким образом, что мы смогли также использовать его для обозначения возвращаемого значения. Здесь мы будем использовать переменную типа, специальный вид переменной, которая работает с типами, а не со значениями.

```ts
function identity<Type>(arg: Type): Type {
    return arg;
}
```

Теперь мы добавили переменную типа `Type` в функцию для идентификации. Этот тип позволяет нам получить тип, который предоставляет пользователь (например, `number`), чтобы мы могли использовать эту информацию позже. Здесь мы снова используем `Type` в качестве возвращаемого типа. При проверке теперь можно увидеть, что для аргумента и возвращаемого значения используется тот же тип. Это позволяет нам передавать информацию типа в одной стороне функции.

Мы говорим, что эта версия `identity` функции является дженерик, так как она работает в диапазоне типов. В отличие от использования `any`, она также столь же точена (т.е. не теряет никакой информации), как и первая `identity` функция, которая использовала числа для аргумента и возвращаемого типа.

После того, как мы написали `identity` как дженерик функцию, мы можем вызвать ее одним из двух способов. Первый способ - передать все аргументы, включая аргумент типа, функции:

```ts
let output = identity<string>("myString"); // let output: string
```

Здесь мы явно задаем тип как `string` в качестве одного из аргументов вызова функции, обозначаемого с помощью `< >` вокруг аргумента, а не `()`.

Второй способ также, пожалуй, самый распространенный. Здесь мы используем вывод аргумента типа - то есть мы хотим, чтобы компилятор установил значение `Type` за нас автоматически на основе типа аргумента, который мы передаем:

```rust
let output = identity("myString"); // let output: string
```

Обратите внимание, что нам не нужно было явно передавать тип в угловых скобках (`< >`); компилятор сам посмотрел на значение «myString» и установил тип `Type`. Хотя вывод аргумента типа может быть полезным инструментом для того, чтобы код был короче и более читаемым, возможно, потребуется явно передать аргументы типа, как это было в предыдущем примере, когда компилятору не удается вывести тип, это может произойти в более сложных примерах.

### Работа с переменными дженерик типа

Когда вы начнете использовать дженерики, вы заметите, что при создании универсальных функций, таких как `identity`, компилятор обеспечит правильное использование любых обобщенно типизированных параметров в теле функции. То есть, вы на самом деле относитесь к этим параметрам, как если бы они могли быть любого типа.

Давайте возьмем нашу функцию `identity` из предыдущих примеров:

```ts
function identity<Type>(arg: Type): Type {
    return arg;
}
```

Что же делать, если мы хотим также регистрировать длину аргумента arg в консоли с каждым вызовом? У нас может возникнуть соблазн написать следующее:

```ts
function loggingIdentity<Type>(arg: Type): Type {
    console.log(arg.length); // Property 'length' does not exist on type 'Type'.
    return arg;
}
```

огда мы это сделаем, компилятор даст нам ошибку, что мы используем `.length` метод `arg`, но нигде мы не сказали, что `arg` имеет этот метод. Помните, ранее мы говорили, что эти переменные типа строятся для любого и всех типов, поэтому кто-то, использующий эту функцию, мог бы иметь number, который не имеет метод `.length`.

Допустим, эта функция действительно предназначена для работы с массивами значений, а не непосредственно со значением. Поскольку мы работаем с массивами, элемент `.length` будет доступен. Мы сможем описать это так же, как мы создаем массивы других типов:

```ts
function loggingIdentity<Type>(arg: Type[]): Type[] {
    console.log(arg.length);
    return arg;
}
```

Тип `loggingIdentity` можно прочитать как «универсальная функция `loggingIdentity` принимает параметр типа `Type` и аргумент `arg`, который является массивом и возвращает массив». Если бы мы передали массив чисел, мы получили бы массив чисел обратно, так как тип связывался бы с числом. Это позволяет нам использовать нашу переменную дженерик типа как часть типов, с которыми мы работаем, а не весь тип, что дает нам большую гибкость.

В качестве альтернативы можно записать пример следующим образом:

```ts
function loggingIdentity<Type>(arg: Array<Type>): Array<Type> {
    console.log(arg.length); // Массив имеет .length, поэтому больше нет ошибок
    return arg;
}
```

Возможно, вы уже знакомы с этим стилем с других языков. В следующем разделе мы рассмотрим, как можно создать собственные дженерик типы, такие как `Array<Type>`.

### Дженерик типы

В предыдущих разделах были созданы дженерик функции `identity` , которые работали с различными типами. В этом разделе рассматривается тип самих функций и способы создания общих интерфейсов.

Тип дженерик функций аналогичен типу других функций с перечисленными параметрами типа, аналогично объявлениям функций:

```ts
function identity<Type>(arg: Type): Type {
    return arg;
}

let myIdentity: <Type>(arg: Type) => Type = identity;
```

Мы также могли бы использовать другое имя для параметра дженерик типа в типе, если бы количество переменных типа и способов использования переменных было больше.

```ts
function identity<Type>(arg: Type): Type {
    return arg;
}

let myIdentity: <Input>(arg: Input) => Input = identity;
```

Можно также записать общий тип как сигнатуру вызова литерального типа объекта:

```ts
function identity<Type>(arg: Type): Type {
    return arg;
}

let myIdentity: { <Type>(arg: Type): Type } = identity;
```

Что приводит нас к написанию нашего первого общего интерфейса. Возьмем литерал объекта из предыдущего примера и переместим его в интерфейс:

```ts
interface GenericIdentityFn {
    <Type>(arg: Type): Type;
}

function identity<Type>(arg: Type): Type {
    return arg;
}

let myIdentity: GenericIdentityFn = identity;
```

В аналогичном примере можно переместить дженерик параметр в качестве параметра всего интерфейса. Это позволяет нам увидеть, какие типы являются универсальными (например, `Dictionary<string>`, а не только `Dictionary`). Это делает параметр `type` видимым для всех остальных элементов интерфейса.

```ts
interface GenericIdentityFn<Type> {
    (arg: Type): Type;
}

function identity<Type>(arg: Type): Type {
    return arg;
}

let myIdentity: GenericIdentityFn<number> = identity;
```

Обратите внимание, что наш пример изменился и стал немного другим. Вместо описания дженерик функции теперь мы имеем сигнатуру не дженерик функции, которая является частью дженерик типа. При использовании `GenericIdentityFn` теперь также необходимо указать соответствующий аргумент типа (здесь: `number`), фактически блокируя то, что будет использовать базовая сигнатура вызова. Понимание того, когда поместить параметр типа непосредственно в сигнатуру вызова и когда поместить его на сам интерфейс, поможет описать, какие аспекты типа являются дженерик.

В дополнение к дженерик интерфейсам можно также создавать дженерик классы. Обратите внимание, что создание дженерик перечислений и пространств имен невозможно.

### Дженерик классы

Дженерик класс имеет форму, аналогичную форме дженерика интерфейса. Общие классы имеют список параметров дженерик типа в угловых скобках (`< >`) после имени класса.

```ts
class GenericNumber<NumType> {
    zeroValue: NumType;
    add: (x: NumType, y: NumType) => NumType;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function (x, y) {
    return x + y;
};
```

Это довольно буквальное использование класса `GenericNumber`, но вы, возможно, заметили, что ничто не ограничивает его только использованием числового типа. Вместо этого мы могли использовать строковые или даже более сложные объекты.

```ts
let stringNumeric = new GenericNumber<string>();
stringNumeric.zeroValue = "";
stringNumeric.add = function (x, y) {
    return x + y;
};

console.log(stringNumeric.add(stringNumeric.zeroValue, "test"));
```

Как и в случае интерфейса, размещение параметра `type` в самом классе позволяет убедиться, что все свойства класса работают с одним и тем же типом.

В разделе, посвященном классам, класс имеет две стороны от своего типа: статическую сторону и сторону экземпляра. Дженерик классы являются универсальными только на стороне экземпляра, а не на их статической стороне, поэтому при работе с классами статические члены не могут использовать параметр типа класса.

### Ограничения дженериков

Если вы помните из более раннего примера, иногда вы можете написать дженерик функцию, которая работает с набором типов, где у вас есть некоторая информация о том, какие возможности будет иметь этот набор типов. В нашем примере `loggingIdentity` мы хотели иметь доступ к свойству `.length` `arg`, но компилятор не смог понять, что каждый тип имеет свойство `.length`, поэтому он предупреждает нас, что мы не можем так сделать.

```ts
function loggingIdentity<Type>(arg: Type): Type {
    console.log(arg.length); // Свойство 'length' не существует в типе 'Type'.
    return arg;
}
```

Вместо работы с `any` и всеми другими типами мы бы хотели ограничить эту функцию работой с `any` и другими типами, которые также имеют свойство `.length`. Пока тип имеет это свойство, мы разрешим его, но он должен иметь хотя бы это свойство. Для этого мы должны перечислить наше требование как ограничение того, каким может быть тип.

Для этого мы создадим интерфейс, описывающий наше ограничение. Здесь мы создадим интерфейс с одним свойством `.length`, а затем будем использовать этот интерфейс и ключевое слово `extensions` для обозначения нашего ограничения:

```ts
interface Lengthwise {
    length: number;
}

function loggingIdentity<Type extends Lengthwise>(arg: Type): Type {
    console.log(arg.length); // Теперь мы знаем, что он имеет свойство `.length`, так что больше никакой ошибки
    return arg;
}
```

Поскольку дженерик функция теперь ограничена, она больше не будет работать со всеми типами:

```ts
loggingIdentity(3); // Аргумент типа 'number' не может быть назначен параметру типа 'Lengthwise'.
```

Вместо этого необходимо передать значения, тип которых имеет все требуемые свойства:

```ts
loggingIdentity({ length: 10, value: 3 });
```

### Использование параметров типа в дженерик ограничениях

Можно объявить параметр типа, который ограничен другим параметром типа. Например, здесь мы хотели бы получить свойство от объекта с его именем. Мы хотим убедиться, что мы не случайно захватываем свойство, которое не существует на объекте, поэтому мы наложим ограничение между двумя типами:

```ts
function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
    return obj[key];
}

let x = { a: 1, b: 2, c: 3, d: 4 };
getProperty(x, "a");
getProperty(x, "m"); // Аргумент типа '"m"' не может быть назначен параметру типа '"a" | "b" | "c" | "d"'.
```

### Использование типов классов в дженериках

При создании фабрик в TypeScript с помощью дженериков необходимо ссылаться на типы классов своими функциями-конструкторами. Например,

```ts
function create<Type>(c: { new (): Type }): Type {
    return new c();
}
```

В более расширенном примере свойство `prototype` используется для формирования и ограничения связей между функцией конструктора и стороной экземпляра типов классов.

```ts
class BeeKeeper {
    hasMask: boolean = true;
}

class ZooKeeper {
    nametag: string = "Mikle";
}

class Animal {
    numLegs: number = 4;
}

class Bee extends Animal {
    keeper: BeeKeeper = new BeeKeeper();
}

class Lion extends Animal {
    keeper: ZooKeeper = new ZooKeeper();
}

function createInstance<A extends Animal>(c: new () => A): A {
    return new c();
}

createInstance(Lion).keeper.nametag;
createInstance(Bee).keeper.hasMask;
```

Этот шаблон используется для создания шаблона конструкции миксинов.
