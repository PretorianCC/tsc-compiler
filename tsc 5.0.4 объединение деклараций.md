## Объединение деклараций

### Введение

Некоторые из уникальных концепций в TypeScript описывают форму объектов JavaScript на уровне типа. Одним из примеров, особенно уникальных для TypeScript, является понятие «объединения объявлений». Понимание этой концепции даст вам преимущество при работе с существующим JavaScript. Это также открывает двери для более продвинутых концепций абстракции.

Для целей этой статьи «объединение объявлений» означает, что компилятор объединяет два отдельных объявления, объявленных с одинаковым именем, в одно определение. Это объединенное определение имеет особенности обоих исходных описаний. Любое количество объявлений может быть объединено, это не ограничивается только двумя декларациями.

### Фундаментальные понятия

В TypeScript объявление создает сущности по крайней мере в одной из трех групп: пространство имен, тип или значение. Объявления, создающие пространство имен, создают пространство имен, содержащее имена, доступ к которым осуществляется с помощью точечной нотации. Создающие тип объявления делают именно это: они создают тип, который виден с объявленной формой и привязан к заданному имени. Наконец, объявления, создающие значения, создают значения, видимые в коде JavaScript.

| Тип объявления | Пространство имен | Тип | Значение |
| -------------- | ----------------- | --- | -------- |
| Namespace      | X                 |     | X        |
| Class          |                   | X   | X        |
| Enum           |                   | X   | X        |
| Interface      |                   | X   |          |
| Type Alias     |                   | X   |          |
| Function       |                   |     | X        |
| Variable       |                   |     | X        |

Понимание того, что создается с каждым объявлением, поможет понять, что объединяется при выполнении объединения объявлений.

### Объединение интерфейсов

Самый простой и, возможно, самый распространенный тип объединения объявлений - объединение интерфейсов. На самом базовом уровне слияние механически соединяет элементы обоих объявлений в единый интерфейс с одним и тем же именем.

```ts
interface Box {
    height: number;
    width: number;
}

interface Box {
    scale: number;
}

let box: Box = { height: 5, width: 6, scale: 10 };
```

Нефункционные элементы интерфейсов должны быть уникальными. Если они не уникальны, они должны быть одного типа. Компилятор выдаст ошибку, если оба интерфейса объявят не-функциональный член с одним именем, но разных типов.

Для членов функции каждый член функции с тем же именем рассматривается как описывающий перегрузку одной и той же функции. Следует также отметить, что в случае слияния интерфейса `А` с более поздним интерфейсом `А`, второй интерфейс будет иметь более высокий приоритет, чем первый.

Это в примере:

```ts
interface Cloner {
    clone(animal: Animal): Animal;
}

interface Cloner {
    clone(animal: Sheep): Sheep;
}

interface Cloner {
    clone(animal: Dog): Dog;
    clone(animal: Cat): Cat;
}
```

Три интерфейса объединяются для создания единого объявления:

```ts
interface Cloner {
    clone(animal: Dog): Dog;
    clone(animal: Cat): Cat;
    clone(animal: Sheep): Sheep;
    clone(animal: Animal): Animal;
}
```

Обратите внимание, что элементы каждой группы сохраняют одинаковый порядок, но сами группы объединяются с последующими наборами перегрузки, упорядоченными первыми.

Исключение из этого правила составляют специализированные подписи. Если сигнатура имеет параметр, тип которого является одиночным строковым литеральным типом (например, не является объединением строковых литералов), то она будет перенесена в верхнюю часть объединенного списка перегрузки.

Например, следующие интерфейсы объединяются:

```ts
interface Document {
    createElement(tagName: any): Element;
}

interface Document {
    createElement(tagName: "div"): HTMLDivElement;
    createElement(tagName: "span"): HTMLSpanElement;
}

interface Document {
    createElement(tagName: string): HTMLElement;
    createElement(tagName: "canvas"): HTMLCanvasElement;
}
```

Итоговое объединенное объявление `Document` будет следующим:

```ts
interface Document {
    createElement(tagName: "canvas"): HTMLCanvasElement;
    createElement(tagName: "div"): HTMLDivElement;
    createElement(tagName: "span"): HTMLSpanElement;
    createElement(tagName: string): HTMLElement;
    createElement(tagName: any): Element;
}
```

### Объединение пространств имен

Аналогично интерфейсам, одноименные пространства имен также объединяют свои члены. Поскольку пространства имен создают и пространство имен, и значение, нам нужно понять, как оба объединяются.

Для объединения пространств имен определения типов из экспортированных интерфейсов, объявленных в каждом пространстве имен, сами объединяются, образуя единое пространство имен с объединенными определениями интерфейсов внутри.

Для объединения значения пространства имен на каждом месте объявления, если пространство имен уже существует с заданным именем, оно дополнительно расширяется, принимая существующее пространство имен и добавляя экспортированные члены второго пространства имен к первому.

Объявление слияние животных в этом примере:

```ts
namespace Animals {
    export class Zebra {}
}

namespace Animals {
    export interface Legged {
        numberOfLegs: number;
    }
    export class Dog {}
}
```

эквивалентно:

```ts
namespace Animals {
    export interface Legged {
        numberOfLegs: number;
    }
    export class Zebra {}
    export class Dog {}
}
```

Эта модель слияния пространств имен является полезным начальным местом, но нам также нужно понять, что происходит с неэкспортными членами. Неэкспортированные члены видны только в исходном (не объединенном) пространстве имен. Это означает, что после объединения объединенные элементы, полученные из других объявлений, не могут видеть не экспортированные элементы.

Мы можем видеть это более ясно в этом примере:

```ts
namespace Animal {
    let haveMuscles = true;
    export function animalsHaveMuscles() {
        return haveMuscles;
    }
}

namespace Animal {
    export function doAnimalsHaveMuscles() {
        return haveMuscles; // Ошибка, потому что haveMuscles не доступен здесь
    }
}
```

Поскольку `haveMuscles` не экспортируется, только функция `animalsHaveMuscles`, которая разделяет то же неслитое пространство имен, видит символ. Функция `doExingMuscles`, даже если она является частью объединенного пространства имен `Animal`, не может видеть этот не экспортированный член.

### Объединение пространств имен с классами, функциями и перечислениями

Пространства имен достаточно гибки, чтобы также объединяться с объявлениями других типов. Для этого объявление пространства имен должно следовать за объявлением, с которым оно будет объединено. Результирующее объявление имеет свойства обоих типов объявления. TypeScript использует эту возможность для моделирования некоторых шаблонов в JavaScript, а также в других языках программирования.

### Объединение пространств имен с классами

Это дает пользователю способ описания внутренних классов.

```ts
class Album {
    label: Album.AlbumLabel;
}

namespace Album {
    export class AlbumLabel {}
}
```

Правила видимости для объединенных членов те же, что описаны в разделе 'Слияние пространств имен', поэтому для их просмотра необходимо экспортировать класс AlbumLabel для объединенного класса. Конечным результатом является класс, управляемый внутри другого класса. Можно также использовать пространства имен для добавления дополнительных статических членов в существующий класс.

В дополнение к шаблону внутренних классов, вы также можете быть знакомы с JavaScript-практикой создания функции и последующего расширения функции путем добавления свойств в функцию. TypeScript использует объединение объявлений для создания определений, подобных этому, безопасным для типов способом.

```ts
function buildLabel(name: string): string {
    return buildLabel.prefix + name + buildLabel.suffix;
}

namespace buildLabel {
    export let suffix = "";
    export let prefix = "Hello, ";
}

console.log(buildLabel("Sam Smith"));
```

Аналогично, пространства имен могут использоваться для расширения перечислений статическими членами:

```ts
enum Color {
    red = 1,
    green = 2,
    blue = 4,
}

namespace Color {
    export function mixColor(colorName: string) {
        if (colorName == "yellow") {
            return Color.red + Color.green;
        } else if (colorName == "white") {
            return Color.red + Color.green + Color.blue;
        } else if (colorName == "magenta") {
            return Color.red + Color.blue;
        } else if (colorName == "cyan") {
            return Color.green + Color.blue;
        }
    }
}
```

### Запрещенные слияния

Не все слияния разрешены в TypeScript. В настоящее время классы не могут объединяться с другими классами или переменными. Сведения о имитации слияния классов см. в разделе Mixins в TypeScript.

### Расширение модуля

Несмотря на то, что модули JavaScript не поддерживают слияние, можно исправлять существующие объекты, импортируя и обновляя их. Давайте посмотрим на игрушечный пример `Observable`:

```ts
// observable.ts
export class Observable<T> {
    // ... реализация оставлена в качестве упражнения для читателя ...
}

// map.ts
import { Observable } from "./observable";

Observable.prototype.map = function (f) {
    // ... еще одно упражнение для читателя
};
```

Это также хорошо работает в TypeScript, но компилятор не знает о `Observable.prototype.map`. Вы можете использовать модуль дополнения, чтобы рассказать компилятору о нем:

```ts
// observable.ts
export class Observable<T> {
    // ... реализация оставлена в качестве упражнения для читателя ...
}

// map.ts
import { Observable } from "./observable";
declare module "./observable" {
    interface Observable<T> {
        map<U>(f: (x: T) => U): Observable<U>;
    }
}
Observable.prototype.map = function (f) {
    // ... еще одно упражнение для читателя
};

// consumer.ts
import { Observable } from "./observable";
import "./map";
let o: Observable<number>;
o.map((x) => x.toFixed());
```

Имя модуля разрешается так же, как спецификаторы модуля при `import`/`export`. Дополнительные сведения см. в разделе Модули. Затем объявления в дополнении объединяются, как если бы они были объявлены в том же файле, что и оригинал.

Однако необходимо помнить о двух ограничениях:

1. Нельзя объявлять новые объявления верхнего уровня в дополнение - просто исправления к существующим объявлениям.
2. Экспорт по умолчанию также не может быть добавлен, только именованный экспорт (так как необходимо добавить экспорт на экспортируемое имя, а `default` зарезервированое слово - подробнее см. [#14080](https://github.com/Microsoft/TypeScript/issues/14080))

### Глобальное дополнение

Можно также добавить объявления в глобальную область из модуля:

```ts
// observable.ts
export class Observable<T> {
    // ... все еще нет реализации ...
}

declare global {
    interface Array<T> {
        toObservable(): Observable<T>;
    }
}

Array.prototype.toObservable = function () {
    // ...
};
```

Глобальные дополнения имеют то же поведение и те же ограничения, что и модули.
